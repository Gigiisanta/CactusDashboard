version: '3'

vars:
  AWS_INSTANCE_ID: "i-022f3394d98803da8"
  SSH_KEY: "cactus-key.pem"
  COMPOSE_FILE: "docker-compose.prod.yml"
  FRONTEND_URL: "http://localhost:3000"
  BACKEND_URL: "http://localhost:8000"

tasks:
  # ===== DESARROLLO LOCAL =====
  dev:
    desc: "🚀 Iniciar desarrollo local completo"
    cmds:
      - task: cleanup
      - echo "🌵 Iniciando CactusDashboard en modo desarrollo..."
      - task: docker:check
      - docker-compose -f {{.COMPOSE_FILE}} up -d
      - echo "⏳ Esperando que los servicios estén listos..."
      - sleep 10
      - task: status:local
      - echo "🎉 Desarrollo iniciado! Frontend http://localhost:3000"

  dev:frontend:
    desc: "🚀 Iniciar solo frontend en localhost:3000"
    cmds:
      - echo "🌵 Iniciando frontend en localhost:3000..."
      - ./scripts/start-frontend.sh

  dev:frontend:clean:
    desc: "🧹 Iniciar frontend con limpieza completa"
    cmds:
      - echo "🧹 Limpiando e iniciando frontend..."
      - task: cleanup:ports
      - cd cactus-wealth-frontend && rm -rf .next node_modules/.cache
      - cd cactus-wealth-frontend && npm install
      - ./scripts/start-frontend.sh

  dev:stop:
    desc: "⏹️ Detener desarrollo local"
    cmds:
      - echo "🛑 Deteniendo servicios locales..."
      - task: docker:check
      - docker-compose -f {{.COMPOSE_FILE}} down
      - task: cleanup
      - echo "✅ Servicios locales detenidos"

  dev:restart:
    desc: "🔄 Reiniciar desarrollo local"
    cmds:
      - task: dev:stop
      - task: dev

  dev:rebuild:
    desc: "🔨 Rebuild completo y reiniciar"
    cmds:
      - echo "🔨 Rebuilding servicios..."
      - task: docker:check
      - docker-compose -f {{.COMPOSE_FILE}} down
      - docker-compose -f {{.COMPOSE_FILE}} build --no-cache
      - docker-compose -f {{.COMPOSE_FILE}} up -d
      - echo "✅ Rebuild completado"

  # ===== LOGS Y DEBUGGING =====
  logs:
    desc: "📺 Ver logs en vivo - todos los servicios"
    cmds:
      - echo "📺 Logs en vivo (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50

  logs:backend:
    desc: "📺 Ver logs del backend"
    cmds:
      - echo "📺 Logs del backend (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50 backend

  logs:frontend:
    desc: "📺 Ver logs del frontend"
    cmds:
      - echo "📺 Logs del frontend (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50 frontend

  logs:db:
    desc: "📺 Ver logs de la base de datos"
    cmds:
      - echo "📺 Logs de la base de datos (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50 db

  debug:
    desc: "🔍 Diagnóstico completo del sistema"
    cmds:
      - echo "🔍 Diagnóstico completo de CactusDashboard..."
      - task: status:local
      - task: health:local
      - task: ports
      - task: resources
      - task: docker:diagnose

  shell:backend:
    desc: "🐚 Shell interactivo en backend"
    cmds:
      - echo "🐚 Entrando al contenedor backend (exit para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} exec backend /bin/bash

  shell:frontend:
    desc: "🐚 Shell interactivo en frontend"
    cmds:
      - echo "🐚 Entrando al contenedor frontend (exit para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} exec frontend /bin/sh

  shell:db:
    desc: "�� Shell PostgreSQL"
    cmds:
      - echo "🐚 Entrando a PostgreSQL (\\q para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} exec db psql -U cactus_user -d cactus_db

  # ===== ESTADO Y SALUD =====
  status:
    desc: "📊 Estado general del sistema"
    cmds:
      - task: status:local

  status:local:
    desc: "📊 Estado de servicios locales"
    cmds:
      - echo "📊 Estado de contenedores Docker:"
      - docker-compose -f {{.COMPOSE_FILE}} ps
      - echo ""
      - echo "🌐 Puertos en uso:"
      - |
        lsof -i :3000 || echo "  Puerto 3000 Libre"
        lsof -i :8000 || echo "  Puerto 8000 Libre"
        lsof -i :5432 || echo "  Puerto 5432 Libre"
        lsof -i :6379 || echo "  Puerto 6379 Libre"

  health:
    desc: "🏥 Verificar salud de servicios"
    cmds:
      - task: health:local

  health:local:
    desc: "🏥 Verificar salud de servicios locales"
    cmds:
      - echo "🏥 Verificando salud de servicios..."
      - |
        if curl -s -I http://localhost:3000 | head -1 | grep -q "200\|30[0-9]"; then
          echo "✅ Frontend (localhost:3000): OK"
        else
          echo "❌ Frontend (localhost:3000): No responde"
        fi
      - |
        if curl -s http://localhost:8000/health > /dev/null 2>&1; then
          echo "✅ Backend (localhost:8000): OK"
        else
          echo "❌ Backend (localhost:8000): No responde"
        fi

  ports:
    desc: "🔌 Verificar puertos en uso"
    cmds:
      - echo "🔌 Verificando puertos..."
      - |
        for port in 3000 8000 5432 6379 80 443; do
          if lsof -i :$port > /dev/null 2>&1; then
            echo "✅ Puerto $port en uso"
          else
            echo "⚪ Puerto $port libre"
          fi
        done

  resources:
    desc: "📈 Mostrar uso de recursos"
    cmds:
      - echo "📈 Uso de recursos del sistema..."
      - echo "🐳 Estadísticas de contenedores:"
      - docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
      - echo ""
      - echo "💻 Sistema:"
      - |
        top -l 1 | grep "CPU usage" || echo "  CPU: No disponible"
      - echo "💾 Disco:"
      - |
        df -h . | tail -1

  # ===== LIMPIEZA Y MANTENIMIENTO =====
  cleanup:
    desc: "🧹 Limpiar puertos y cachés"
    cmds:
      - echo "🧹 Limpiando puertos y cachés..."
      - task: cleanup:ports
      - task: cleanup:frontend
      - echo "✅ Limpieza completada"

  cleanup:ports:
    desc: "🧹 Limpiar solo puertos (3000, 3001, 8000, 8080)"
    cmds:
      - echo "🧹 Limpiando puertos..."
      - ./scripts/cleanup-ports.sh
      - echo "✅ Puertos limpiados"

  cleanup:frontend:
    desc: "🧹 Limpiar caché y build del frontend"
    cmds:
      - echo "🧹 Limpiando frontend..."
      - |
        cd cactus-wealth-frontend
        rm -rf .next node_modules/.cache dist build
        echo "🗑️ Archivos de build y caché eliminados"
      - echo "✅ Frontend limpiado"

  # ===== AWS GESTIÓN =====
  aws:start:
    desc: "▶️ Iniciar instancia EC2"
    cmds:
      - echo "▶️ Iniciando instancia EC2..."
      - |
        current_state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        if [ "$current_state" = "running" ]; then
          echo "⚠️ La instancia ya está ejecutándose"
          ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "🌐 IP pública: $ip"
          echo "🔗 URL: http://$ip"
        else
          aws ec2 start-instances --instance-ids {{.AWS_INSTANCE_ID}} > /dev/null
          echo "⏳ Esperando que la instancia esté lista..."
          aws ec2 wait instance-running --instance-ids {{.AWS_INSTANCE_ID}}
          ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "✅ Instancia iniciada exitosamente"
          echo "🌐 IP pública: $ip"
          echo "🔗 URL: http://$ip"
        fi

  aws:stop:
    desc: "⏹️ Detener instancia EC2 (ahorrar dinero)"
    cmds:
      - echo "⏹️ Deteniendo instancia EC2..."
      - |
        current_state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        if [ "$current_state" = "stopped" ]; then
          echo "⚠️ La instancia ya está detenida"
        else
          aws ec2 stop-instances --instance-ids {{.AWS_INSTANCE_ID}} > /dev/null
          echo "⏳ Esperando que la instancia se detenga..."
          aws ec2 wait instance-stopped --instance-ids {{.AWS_INSTANCE_ID}}
          echo "✅ Instancia detenida exitosamente"
          echo "💰 ¡Dinero ahorrado! La instancia ya no genera costos"
        fi

  aws:status:
    desc: "📊 Estado de la instancia EC2"
    cmds:
      - echo "📊 Verificando estado de la instancia EC2..."
      - |
        state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        type=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].InstanceType' --output text 2>/dev/null || echo "unknown")
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        
        echo "🆔 ID: {{.AWS_INSTANCE_ID}}"
        echo "📦 Tipo: $type"
        echo "🔄 Estado: $state"
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "🌐 IP pública: $ip"
          echo "🔗 URL: http://$ip"
        else
          echo "🌐 IP pública: No asignada"
        fi

  aws:ip:
    desc: "🌐 Obtener IP pública de la instancia"
    cmds:
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "🌐 IP pública: $ip"
          echo "🔗 URL: http://$ip"
        else
          echo "❌ No hay IP pública asignada (instancia detenida?)"
        fi

  aws:costs:
    desc: "💰 Ver información de costos"
    cmds:
      - echo "💰 Información de costos AWS..."
      - |
        type=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].InstanceType' --output text 2>/dev/null || echo "unknown")
        state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        
        echo "📦 Tipo de instancia: $type"
        echo "🔄 Estado actual: $state"
        echo ""
        echo "💡 Costos estimados por hora (región us-east-1):"
        case $type in
          "t2.micro") echo "   💵 \$0.0116/hora (~\$8.50/mes)" ;;
          "t2.small") echo "   💵 \$0.023/hora (~\$17/mes)" ;;
          "t2.medium") echo "   💵 \$0.046/hora (~\$34/mes)" ;;
          "t3.micro") echo "   💵 \$0.0104/hora (~\$7.60/mes)" ;;
          "t3.small") echo "   💵 \$0.0208/hora (~\$15/mes)" ;;
          *) echo "   💵 Consulta AWS Pricing para $type" ;;
        esac
        echo ""
        if [ "$state" = "running" ]; then
          echo "⚠️ La instancia está EJECUTÁNDOSE - generando costos"
          echo "💡 Usa 'task aws:stop' para detenerla y ahorrar dinero"
        else
          echo "✅ La instancia está DETENIDA - sin costos de cómputo"
          echo "💡 Usa 'task aws:start' para iniciarla cuando la necesites"
        fi

  aws:ssh:
    desc: "🔐 Conectar SSH a la instancia"
    cmds:
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "🔐 Conectando SSH a $ip..."
          ssh -i {{.SSH_KEY}} ubuntu@$ip
        else
          echo "❌ No se puede conectar: instancia sin IP pública"
          echo "💡 Usa 'task aws:start' primero"
        fi

  aws:health:
    desc: "🏥 Verificar salud de servicios en AWS"
    cmds:
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "🏥 Verificando salud de servicios en $ip..."
          if curl -s -I http://$ip | head -1 | grep -q "200\|30[0-9]"; then
            echo "✅ Aplicación web: OK"
          else
            echo "❌ Aplicación web: No responde"
          fi
          if curl -s http://$ip/api/health > /dev/null 2>&1; then
            echo "✅ API Backend: OK"
          else
            echo "❌ API Backend: No responde"
          fi
        else
          echo "❌ No se puede verificar: instancia sin IP pública"
        fi

  # ===== DESPLIEGUE =====
  deploy:aws:
    desc: "🚀 Desplegar a AWS"
    cmds:
      - echo "🚀 Desplegando CactusDashboard a AWS..."
      - task: aws:start
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
        echo "📦 Desplegando aplicación en $ip..."
        
        if ssh -i {{.SSH_KEY}} -o ConnectTimeout=10 ubuntu@$ip "echo 'Conexión SSH exitosa'" > /dev/null 2>&1; then
          echo "✅ Conexión SSH establecida"
          
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && docker-compose -f docker-compose.prod.yml down"
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && git pull origin main"
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && docker-compose -f docker-compose.prod.yml build"
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && docker-compose -f docker-compose.prod.yml up -d"
          
          echo "⏳ Esperando que los servicios estén listos..."
          sleep 30
          
          if curl -s -I http://$ip | head -1 | grep -q "200\|30[0-9]"; then
            echo "✅ Despliegue exitoso!"
            echo "🌐 Aplicación disponible en: http://$ip"
          else
            echo "❌ Error en el despliegue - la aplicación no responde"
          fi
        else
          echo "❌ Error: No se puede conectar SSH a la instancia"
        fi

  # ===== TAREAS INTERNAS =====
  _check:docker:
    desc: "🔍 Verificación interna de Docker"
    internal: true
    cmds:
      - |
        if ! docker info >/dev/null 2>&1; then
          echo "❌ Docker no está ejecutándose"
          echo "💡 Inicia Docker Desktop y vuelve a intentar"
          exit 1
        fi

  # ===== CONFIGURACIÓN Y VALIDACIÓN =====
  docker:check:
    desc: "🐳 Verificar y asegurar que Docker esté ejecutándose"
    cmds:
      - echo "🐳 Verificando Docker..."
      - ./scripts/check-docker.sh

  docker:setup:
    desc: "🐳 Configurar Docker Desktop para inicio automático"
    cmds:
      - echo "🐳 Configurando Docker Desktop..."
      - ./scripts/setup-docker-autostart.sh

  docker:diagnose:
    desc: "🔍 Diagnóstico completo de Docker"
    cmds:
      - echo "🔍 Ejecutando diagnóstico completo de Docker..."
      - ./scripts/diagnose-docker.sh

  setup:
    desc: "⚙️ Configuración inicial del proyecto"
    cmds:
      - echo "⚙️ Configurando CactusDashboard..."
      - echo "📋 Verificando dependencias..."
      - |
        docker --version || echo "❌ Docker no instalado"
        docker-compose --version || echo "❌ Docker Compose no instalado"
        aws --version || echo "❌ AWS CLI no instalado"
      - echo "📁 Verificando archivos de configuración..."
      - |
        test -f docker-compose.prod.yml && echo "✅ docker-compose.prod.yml" || echo "❌ docker-compose.prod.yml no encontrado"
        test -f {{.SSH_KEY}} && echo "✅ SSH key encontrada" || echo "❌ SSH key {{.SSH_KEY}} no encontrada"
      - echo "✅ Configuración inicial completada"

  validate:
    desc: "✅ Validar configuración del proyecto"
    cmds:
      - echo "✅ Validando configuración de CactusDashboard..."
      - task: setup
      - echo "🔍 Validando configuración AWS..."
      - |
        aws sts get-caller-identity > /dev/null && echo "✅ AWS CLI configurado" || echo "❌ AWS CLI no configurado"
      - echo "🔍 Validando instancia EC2..."
      - task: aws:status
      - echo "✅ Validación completada"

  # ===== OAUTH Y AUTENTICACIÓN =====
  oauth:verify:
    desc: "🔐 Verificar configuración OAuth"
    cmds:
      - echo "🔐 Verificando configuración OAuth..."
      - |
        if [ -f "cactus-wealth-frontend/.env.local" ]; then
          echo "📁 Archivo .env.local encontrado"
          
          nextauth_url=$(grep "NEXTAUTH_URL=" cactus-wealth-frontend/.env.local | cut -d'=' -f2 | tr -d '"' || echo "")
          google_client_id=$(grep "GOOGLE_CLIENT_ID=" cactus-wealth-frontend/.env.local | cut -d'=' -f2 | tr -d '"' || echo "")
          
          if [ ! -z "$nextauth_url" ]; then
            echo "✅ NEXTAUTH_URL: $nextauth_url"
            echo ""
            echo "🔧 Configuración requerida en Google Console:"
            echo "   📍 Authorized JavaScript origins:"
            echo "      $nextauth_url"
            echo "   📍 Authorized redirect URIs:"
            echo "      $nextauth_url/api/auth/callback/google"
            echo ""
          else
            echo "❌ NEXTAUTH_URL no encontrado en .env.local"
          fi
          
          if [ ! -z "$google_client_id" ]; then
            echo "✅ GOOGLE_CLIENT_ID configurado"
          else
            echo "❌ GOOGLE_CLIENT_ID no encontrado en .env.local"
          fi
          
          echo "🔗 Google Console: https://console.developers.google.com/apis/credentials"
        else
          echo "❌ Archivo .env.local no encontrado en cactus-wealth-frontend/"
          echo "💡 Crea el archivo basándote en .env.example"
        fi

  oauth:update:
    desc: "🔄 Actualizar credenciales OAuth de Google"
    cmds:
      - |
        echo "🔄 Actualizando credenciales OAuth..."
        echo ""
        echo "📋 Uso: task oauth:update CLIENT_ID=tu_client_id CLIENT_SECRET=tu_client_secret"
        echo ""
        echo "📝 Ejemplo:"
        echo "   task oauth:update CLIENT_ID=123456789-abcdef.apps.googleusercontent.com CLIENT_SECRET=GOCSPX-abcdef123456"
        echo ""
        echo "🔗 Para obtener credenciales:"
        echo "   1. Ve a: https://console.cloud.google.com/apis/credentials"
        echo "   2. Crea OAuth 2.0 Client ID (Web application)"
        echo "   3. Configura URLs autorizadas:"
        echo "      - JavaScript origins: http://localhost:3000"
        echo "      - Redirect URIs: http://localhost:3000/api/auth/callback/google"
        echo ""
        
        if [ -z "{{.CLIENT_ID}}" ] || [ -z "{{.CLIENT_SECRET}}" ]; then
          echo "❌ Error: Debes proporcionar CLIENT_ID y CLIENT_SECRET"
          echo ""
          echo "💡 Ejemplo de uso correcto:"
          echo "   task oauth:update CLIENT_ID=tu_client_id CLIENT_SECRET=tu_client_secret"
          exit 1
        fi
        
        echo "🔧 Ejecutando script de actualización..."
        ./update-oauth-credentials.sh "{{.CLIENT_ID}}" "{{.CLIENT_SECRET}}"
        echo ""
        echo "✅ ¡Credenciales OAuth actualizadas!"
        echo "🌐 Prueba la autenticación en: http://localhost:3000"

  oauth:diagnose:
    desc: "🔍 Diagnóstico completo de OAuth"
    cmds:
      - echo "🔍 Ejecutando diagnóstico completo de OAuth..."
      - ./diagnose-oauth.sh

  oauth:test:
    desc: "🧪 Probar configuración OAuth"
    cmds:
      - echo "🧪 Probando configuración OAuth..."
      - ./scripts/test-oauth.sh

  oauth:monitor:
    desc: "📊 Monitorear estado OAuth automáticamente"
    cmds:
      - echo "📊 Iniciando monitoreo OAuth..."
      - ./scripts/monitor-oauth.sh

  oauth:setup-monitoring:
    desc: "📊 Configurar monitoreo automático de OAuth"
    cmds:
      - echo "📊 Configurando monitoreo automático de OAuth..."
      - ./scripts/setup-oauth-monitoring.sh

  # ===== AYUDA =====
  help:
    desc: "❓ Mostrar ayuda completa y organizada"
    cmds:
      - |
        echo "🌵 CACTUS DASHBOARD - SISTEMA TASK UNIFICADO"
        echo "══════════════════════════════════════════════════════════════════════════════"
        echo ""
        echo "🚀 DESARROLLO LOCAL:"
        echo "  task dev              # Iniciar desarrollo completo"
        echo "  task dev:stop         # Detener desarrollo"
        echo "  task dev:restart      # Reiniciar desarrollo"
        echo "  task dev:rebuild      # Rebuild completo"
        echo ""
        echo "📺 LOGS & DEBUGGING:"
        echo "  task logs             # Ver logs en vivo (todos los servicios)"
        echo "  task logs:backend     # Solo logs del backend"
        echo "  task logs:frontend    # Solo logs del frontend"
        echo "  task logs:db          # Solo logs de la base de datos"
        echo "  task debug            # Diagnóstico completo del sistema"
        echo ""
        echo "📊 MONITOREO & ESTADO:"
        echo "  task status           # Estado general del sistema"
        echo "  task health           # Verificar salud de todos los servicios"
        echo "  task ports            # Verificar puertos en uso"
        echo "  task resources        # Mostrar uso de CPU, memoria y disco"
        echo ""
        echo "🔍 HEALTH CHECKS GRANULARES:"
        echo "  task health:services  # Verificar servicios Docker"
        echo "  task health:endpoints # Verificar endpoints HTTP"
        echo "  task health:database  # Verificar conexión a base de datos"
        echo "  task health:auth      # Verificar configuración de autenticación"
        echo "  task health:resources # Verificar uso de recursos del sistema"
        echo ""
        echo "📊 MONITOREO AVANZADO:"
        echo "  task monitor:continuous      # Monitoreo continuo (sin Docker)"
        echo "  task monitor:continuous-full # Monitoreo continuo completo"
        echo "  task monitor:logs           # Monitoreo de logs con filtros"
        echo ""
        echo "🔍 DIAGNÓSTICOS AVANZADOS:"
        echo "  task diagnose:all         # Ejecutar todos los diagnósticos"
        echo "  task diagnose:network     # Diagnóstico de red y conectividad"
        echo "  task diagnose:performance # Diagnóstico de rendimiento"
        echo "  task diagnose:security    # Diagnóstico de seguridad"
        echo "  task diagnose:dependencies # Diagnóstico de dependencias"
        echo ""
        echo "☁️ AWS MANAGEMENT:"
        echo "  task aws:start        # Iniciar instancia EC2"
        echo "  task aws:stop         # Detener instancia (ahorrar dinero)"
        echo "  task aws:status       # Estado de la instancia EC2"
        echo "  task aws:ip           # Obtener IP pública actual"
        echo "  task aws:costs        # Ver información de costos"
        echo "  task aws:ssh          # Conectar SSH a la instancia"
        echo "  task aws:health       # Verificar salud de servicios en AWS"
        echo ""
        echo "🚀 DEPLOYMENT:"
        echo "  task deploy:aws       # Desplegar aplicación completa a AWS"
        echo ""
        echo "🔐 OAUTH & AUTENTICACIÓN:"
        echo "  task oauth:verify     # Verificar configuración OAuth"
        echo "  task oauth:update     # Actualizar credenciales OAuth"
        echo "  task oauth:diagnose   # Diagnóstico completo de OAuth"
        echo "  task oauth:test       # Probar configuración OAuth"
        echo "  task oauth:monitor    # Monitorear estado OAuth automáticamente"
        echo "  task oauth:setup-permanent # Configurar OAuth permanente"
        echo ""
        echo "⚙️ CONFIGURACIÓN & UTILIDADES:"
        echo "  task setup            # Configuración inicial del proyecto"
        echo "  task validate         # Validar toda la configuración"
        echo "  task docker:check     # Verificar Docker"
        echo "  task docker:setup     # Configurar Docker Desktop"
        echo "  task docker:diagnose  # Diagnóstico completo de Docker"
        echo "  task cleanup          # Limpiar puertos y cachés"
        echo ""
        echo "❓ AYUDA & INFORMACIÓN:"
        echo "  task help             # Esta ayuda completa"
        echo "  task help:quick       # Ayuda rápida (comandos esenciales)"
        echo "  task --list           # Lista rápida de todos los comandos"
        echo ""
        echo "💡 EJEMPLOS DE USO:"
        echo "  * Desarrollo diario: task dev, task logs, task status, task dev:stop"
        echo "  * Gestión AWS: task aws:start, task deploy:aws, task aws:stop"
        echo "  * OAuth: task oauth:diagnose, task oauth:update, task oauth:test"
        echo "  * Health Checks: task health:endpoints, task health:auth, task health:resources"
        echo "  * Monitoreo: task monitor:continuous, task diagnose:all"
        echo "  * Troubleshooting: task debug, task cleanup, task validate, task diagnose:network"
        echo ""
        echo "🎉 SISTEMA UNIFICADO:"
        echo "  ✅ Todos los scripts consolidados en Task"
        echo "  ✅ Sintaxis consistente: task <comando>"
        echo "  ✅ Documentación integrada y autocompletado"
        echo "  ✅ Optimización del 90%+ en tiempos de ejecución"
        echo ""
        echo "📚 Documentación: DOCUMENTATION.md, TASK_SYSTEM.md, QUICK_REFERENCE.md"

  help:quick:
    desc: "⚡ Ayuda rápida - comandos esenciales"
    cmds:
      - |
        echo ""
        echo "⚡ COMANDOS ESENCIALES - CACTUS DASHBOARD"
        echo "════════════════════════════════════════"
        echo ""
        echo "🚀 DESARROLLO:"
        echo "   task dev              # Iniciar desarrollo"
        echo "   task dev:stop         # Detener desarrollo"
        echo "   task logs             # Ver logs en vivo"
        echo "   task status           # Estado del sistema"
        echo ""
        echo "☁️ AWS:"
        echo "   task aws:start        # Iniciar instancia EC2"
        echo "   task aws:stop         # Detener instancia (ahorrar dinero)"
        echo "   task deploy:aws       # Desplegar a AWS"
        echo ""
        echo "🔐 OAUTH:"
        echo "   task oauth:diagnose   # Diagnóstico OAuth"
        echo "   task oauth:test       # Probar OAuth"
        echo "   task oauth:update     # Actualizar credenciales"
        echo ""
        echo "🔧 UTILIDADES:"
        echo "   task debug            # Diagnóstico completo"
        echo "   task cleanup          # Limpiar puertos"
        echo "   task help             # Ayuda completa"
        echo ""
        echo "💡 Usa 'task help' para ver todos los comandos disponibles"
        echo ""

  # ===== FASE 2: HEALTH CHECKS GRANULARES =====
  health:services:
    desc: "🔍 Verificar estado de servicios Docker"
    deps: [_check:docker]
    cmds:
      - echo "🔍 Verificando estado de servicios Docker..."
      - |
        if {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} ps | grep -q "Up"; then
          echo "✅ Servicios Docker ejecutándose:"
          {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
        else
          echo "❌ No hay servicios Docker ejecutándose"
          echo "💡 Usa 'task dev' para iniciar los servicios"
        fi

  health:endpoints:
    desc: "🌐 Verificar endpoints HTTP"
    cmds:
      - echo "🌐 Verificando endpoints HTTP..."
      - |
        check_endpoint() {
          local url=$1
          local name=$2
          echo -n "  $name ($url): "
          if curl -s --max-time 5 "$url" > /dev/null 2>&1; then
            echo "✅ OK"
          else
            echo "❌ FAIL"
          fi
        }
        
        check_endpoint "{{.FRONTEND_URL}}" "Frontend"
        check_endpoint "{{.BACKEND_URL}}/health" "Backend Health"
        check_endpoint "{{.FRONTEND_URL}}/api/auth/providers" "NextAuth Providers"

  health:database:
    desc: "🗄️ Verificar conexión a base de datos"
    deps: [_check:docker]
    cmds:
      - echo "🗄️ Verificando conexión a base de datos..."
      - |
        if {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} ps db | grep -q "Up"; then
          echo "✅ Contenedor de base de datos ejecutándose"
          echo -n "  Conexión PostgreSQL: "
          if {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} exec -T db pg_isready -U cactus_user > /dev/null 2>&1; then
            echo "✅ OK"
          else
            echo "❌ FAIL"
          fi
        else
          echo "❌ Contenedor de base de datos no está ejecutándose"
        fi

  health:auth:
    desc: "🔐 Verificar configuración de autenticación"
    cmds:
      - echo "🔐 Verificando configuración de autenticación..."
      - |
        check_env_var() {
          local var_name=$1
          local file_path=$2
          if grep -q "^$var_name=" "$file_path" 2>/dev/null; then
            echo "  ✅ $var_name configurado"
          else
            echo "  ❌ $var_name no configurado"
          fi
        }
        
        if [ -f ".env" ]; then
          echo "📁 Verificando .env:"
          check_env_var "NEXTAUTH_SECRET" ".env"
          check_env_var "GOOGLE_CLIENT_ID" ".env"
          check_env_var "GOOGLE_CLIENT_SECRET" ".env"
        else
          echo "❌ Archivo .env no encontrado"
        fi

  health:resources:
    desc: "💻 Verificar uso de recursos del sistema"
    cmds:
      - echo "💻 Verificando uso de recursos del sistema..."
      - |
        echo "📊 CPU y Memoria:"
        if command -v top >/dev/null 2>&1; then
          top -l 1 -n 0 | grep "CPU usage\|PhysMem"
        fi
        
        echo ""
        echo "💾 Espacio en disco:"
        df -h / | tail -1 | awk '{print "  Usado: " $3 " / " $2 " (" $5 ")"}'
        
        echo ""
        echo "🐳 Recursos Docker:"
        if docker system df >/dev/null 2>&1; then
          docker system df
        else
          echo "  ❌ Docker no disponible"
        fi

  # ===== FASE 2: MONITOREO AVANZADO =====
  monitor:continuous:
    desc: "📊 Monitoreo continuo del sistema"
    cmds:
      - echo "📊 Iniciando monitoreo continuo (Ctrl+C para detener)..."
      - |
        while true; do
          clear
          echo "🌵 CACTUS DASHBOARD - MONITOREO CONTINUO"
          echo "════════════════════════════════════════"
          date
          echo ""
          
          # Solo ejecutar health checks que no dependan de Docker
          echo "🔍 Health Checks:"
          task health:endpoints --silent || echo "❌ Endpoints no disponibles"
          echo ""
          task health:auth --silent || echo "❌ Auth no configurado"
          echo ""
          task health:resources --silent || echo "❌ Error en recursos"
          
          echo ""
          echo "🔄 Actualizando en 30 segundos... (Ctrl+C para detener)"
          sleep 30
        done

  monitor:continuous-full:
    desc: "📊 Monitoreo continuo completo (requiere Docker)"
    cmds:
      - echo "📊 Iniciando monitoreo continuo completo (Ctrl+C para detener)..."
      - |
        while true; do
          clear
          echo "🌵 CACTUS DASHBOARD - MONITOREO CONTINUO COMPLETO"
          echo "═══════════════════════════════════════════════════"
          date
          echo ""
          
          task health:services --silent
          echo ""
          task health:endpoints --silent
          echo ""
          task health:auth --silent
          echo ""
          task health:resources --silent
          
          echo ""
          echo "🔄 Actualizando en 30 segundos... (Ctrl+C para detener)"
          sleep 30
        done

  monitor:logs:
    desc: "📺 Monitoreo de logs con filtros"
    cmds:
      - echo "📺 Monitoreo de logs con filtros..."
      - |
        echo "Filtros disponibles:"
        echo "  1. Errores (error, exception, failed)"
        echo "  2. Autenticación (auth, oauth, login)"
        echo "  3. Base de datos (database, sql, postgres)"
        echo "  4. Todos los logs"
        echo ""
        read -p "Selecciona filtro (1-4): " filter
        
        case $filter in
          1) {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} logs -f --tail=100 | grep -i "error\|exception\|failed" ;;
          2) {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} logs -f --tail=100 | grep -i "auth\|oauth\|login" ;;
          3) {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} logs -f --tail=100 | grep -i "database\|sql\|postgres" ;;
          4) {{.DOCKER_COMPOSE_CMD}} -f {{.COMPOSE_FILE}} logs -f --tail=100 ;;
          *) echo "❌ Opción inválida" ;;
        esac

  # ===== FASE 2: DIAGNÓSTICOS AVANZADOS =====
  diagnose:network:
    desc: "🌐 Diagnóstico de red y conectividad"
    cmds:
      - echo "🌐 Diagnóstico de red y conectividad..."
      - |
        echo "📡 Puertos en uso:"
        netstat -an | grep LISTEN | grep -E ":3000|:8000|:5432|:6379" || echo "  No hay puertos relevantes en uso"
        
        echo ""
        echo "🔗 Conectividad externa:"
        ping -c 3 google.com >/dev/null 2>&1 && echo "  ✅ Internet OK" || echo "  ❌ Sin conexión a internet"
        
        echo ""
        echo "🐳 Red Docker:"
        if docker network ls >/dev/null 2>&1; then
          docker network ls | grep cactus || echo "  No hay redes Docker de Cactus"
        else
          echo "  ❌ Docker no disponible"
        fi

  diagnose:performance:
    desc: "⚡ Diagnóstico de rendimiento"
    cmds:
      - echo "⚡ Diagnóstico de rendimiento..."
      - echo "🚀 Tiempo de respuesta de endpoints:"
      - |
        echo -n "  Frontend: "
        if curl -o /dev/null -s --max-time 5 "http://localhost:3000" 2>/dev/null; then
          time_result=$(curl -o /dev/null -s -w "%{time_total}" --max-time 10 "http://localhost:3000" 2>/dev/null || echo "error")
          if [ "$time_result" != "error" ]; then
            echo "${time_result}s"
          else
            echo "❌ ERROR"
          fi
        else
          echo "❌ NO DISPONIBLE"
        fi
      - |
        echo -n "  Backend: "
        if curl -o /dev/null -s --max-time 5 "http://localhost:8000/health" 2>/dev/null; then
          time_result=$(curl -o /dev/null -s -w "%{time_total}" --max-time 10 "http://localhost:8000/health" 2>/dev/null || echo "error")
          if [ "$time_result" != "error" ]; then
            echo "${time_result}s"
          else
            echo "❌ ERROR"
          fi
        else
          echo "❌ NO DISPONIBLE"
        fi
      - echo ""
      - echo "💾 Rendimiento de disco:"
      - |
        echo "  Escribiendo 10MB..."
        if dd if=/dev/zero of=/tmp/test_write bs=1m count=10 2>/dev/null; then
          echo "  ✅ Test de escritura completado"
          rm -f /tmp/test_write 2>/dev/null
        else
          echo "  ❌ Error en test de escritura"
        fi

  diagnose:security:
    desc: "🔒 Diagnóstico de seguridad"
    cmds:
      - echo "🔒 Diagnóstico de seguridad..."
      - |
        echo "🔐 Verificación de secretos:"
        
        check_secret() {
          local var_name=$1
          local file_path=$2
          if grep -q "^$var_name=" "$file_path" 2>/dev/null; then
            local value=$(grep "^$var_name=" "$file_path" | cut -d'=' -f2 | tr -d '"')
            if [ ${#value} -gt 20 ]; then
              echo "  ✅ $var_name: Longitud adecuada (${#value} chars)"
            else
              echo "  ⚠️ $var_name: Muy corto (${#value} chars)"
            fi
          else
            echo "  ❌ $var_name: No configurado"
          fi
        }
        
        if [ -f ".env" ]; then
          check_secret "NEXTAUTH_SECRET" ".env"
          check_secret "GOOGLE_CLIENT_SECRET" ".env"
        fi
        
        echo ""
        echo "🔒 Permisos de archivos sensibles:"
        for file in .env .env.local; do
          if [ -f "$file" ]; then
            perms=$(ls -la "$file" | awk '{print $1}')
            echo "  $file: $perms"
          fi
        done

  diagnose:dependencies:
    desc: "📦 Diagnóstico de dependencias"
    cmds:
      - echo "📦 Diagnóstico de dependencias..."
      - |
        echo "🔧 Herramientas del sistema:"
        
        check_tool() {
          local tool=$1
          local name=$2
          if command -v "$tool" >/dev/null 2>&1; then
            local version=$($tool --version 2>/dev/null | head -1 || echo "versión desconocida")
            echo "  ✅ $name: $version"
          else
            echo "  ❌ $name: No instalado"
          fi
        }
        
        check_tool "docker" "Docker"
        check_tool "node" "Node.js"
        check_tool "npm" "NPM"
        check_tool "python3" "Python"
        check_tool "curl" "cURL"
        check_tool "git" "Git"
        
        echo ""
        echo "📦 Dependencias del proyecto:"
        if [ -f "cactus-wealth-frontend/package.json" ]; then
          echo "  ✅ Frontend package.json encontrado"
          if [ -f "cactus-wealth-frontend/node_modules" ]; then
            echo "  ✅ Frontend node_modules instalado"
          else
            echo "  ❌ Frontend node_modules no encontrado"
          fi
        fi
        
        if [ -f "cactus-wealth-backend/requirements.txt" ]; then
          echo "  ✅ Backend requirements.txt encontrado"
        fi

  diagnose:all:
    desc: "🔍 Ejecutar todos los diagnósticos disponibles"
    cmds:
      - echo "🔍 DIAGNÓSTICO COMPLETO DEL SISTEMA"
      - echo "═══════════════════════════════════════"
      - echo ""
      - task diagnose:network
      - echo ""
      - task diagnose:performance
      - echo ""
      - task diagnose:security
      - echo ""
      - task diagnose:dependencies
      - echo ""
      - echo "✅ Diagnóstico completo finalizado"