version: '3'

vars:
  AWS_INSTANCE_ID: "i-022f3394d98803da8"
  SSH_KEY: "cactus-key.pem"
  COMPOSE_FILE: "docker-compose.prod.yml"

tasks:
  # ===== DESARROLLO LOCAL =====
  dev:
    desc: "ğŸš€ Iniciar desarrollo local completo"
    cmds:
      - task: cleanup
      - echo "ğŸŒµ Iniciando CactusDashboard en modo desarrollo..."
      - task: docker:check
      - docker-compose -f {{.COMPOSE_FILE}} up -d
      - echo "â³ Esperando que los servicios estÃ©n listos..."
      - sleep 10
      - task: status:local
      - echo "ğŸ‰ Desarrollo iniciado! Frontend http://localhost:3000"

  dev:frontend:
    desc: "ğŸš€ Iniciar solo frontend en localhost:3000"
    cmds:
      - echo "ğŸŒµ Iniciando frontend en localhost:3000..."
      - ./scripts/start-frontend.sh

  dev:frontend:clean:
    desc: "ğŸ§¹ Iniciar frontend con limpieza completa"
    cmds:
      - echo "ğŸ§¹ Limpiando e iniciando frontend..."
      - task: cleanup:ports
      - cd cactus-wealth-frontend && rm -rf .next node_modules/.cache
      - cd cactus-wealth-frontend && npm install
      - ./scripts/start-frontend.sh

  dev:stop:
    desc: "â¹ï¸ Detener desarrollo local"
    cmds:
      - echo "ğŸ›‘ Deteniendo servicios locales..."
      - task: docker:check
      - docker-compose -f {{.COMPOSE_FILE}} down
      - task: cleanup
      - echo "âœ… Servicios locales detenidos"

  dev:restart:
    desc: "ğŸ”„ Reiniciar desarrollo local"
    cmds:
      - task: dev:stop
      - task: dev

  dev:rebuild:
    desc: "ğŸ”¨ Rebuild completo y reiniciar"
    cmds:
      - echo "ğŸ”¨ Rebuilding servicios..."
      - task: docker:check
      - docker-compose -f {{.COMPOSE_FILE}} down
      - docker-compose -f {{.COMPOSE_FILE}} build --no-cache
      - docker-compose -f {{.COMPOSE_FILE}} up -d
      - echo "âœ… Rebuild completado"

  # ===== LOGS Y DEBUGGING =====
  logs:
    desc: "ğŸ“º Ver logs en vivo - todos los servicios"
    cmds:
      - echo "ğŸ“º Logs en vivo (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50

  logs:backend:
    desc: "ğŸ“º Ver logs del backend"
    cmds:
      - echo "ğŸ“º Logs del backend (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50 backend

  logs:frontend:
    desc: "ğŸ“º Ver logs del frontend"
    cmds:
      - echo "ğŸ“º Logs del frontend (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50 frontend

  logs:db:
    desc: "ğŸ“º Ver logs de la base de datos"
    cmds:
      - echo "ğŸ“º Logs de la base de datos (Ctrl+C para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} logs -f --tail=50 db

  debug:
    desc: "ğŸ” DiagnÃ³stico completo del sistema"
    cmds:
      - echo "ğŸ” DiagnÃ³stico completo de CactusDashboard..."
      - task: status:local
      - task: health:local
      - task: ports
      - task: resources
      - task: docker:diagnose

  shell:backend:
    desc: "ğŸš Shell interactivo en backend"
    cmds:
      - echo "ğŸš Entrando al contenedor backend (exit para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} exec backend /bin/bash

  shell:frontend:
    desc: "ğŸš Shell interactivo en frontend"
    cmds:
      - echo "ğŸš Entrando al contenedor frontend (exit para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} exec frontend /bin/sh

  shell:db:
    desc: "ï¿½ï¿½ Shell PostgreSQL"
    cmds:
      - echo "ğŸš Entrando a PostgreSQL (\\q para salir)..."
      - docker-compose -f {{.COMPOSE_FILE}} exec db psql -U cactus_user -d cactus_db

  # ===== ESTADO Y SALUD =====
  status:
    desc: "ğŸ“Š Estado general del sistema"
    cmds:
      - task: status:local

  status:local:
    desc: "ğŸ“Š Estado de servicios locales"
    cmds:
      - echo "ğŸ“Š Estado de contenedores Docker:"
      - docker-compose -f {{.COMPOSE_FILE}} ps
      - echo ""
      - echo "ğŸŒ Puertos en uso:"
      - |
        lsof -i :3000 || echo "  Puerto 3000 Libre"
        lsof -i :8000 || echo "  Puerto 8000 Libre"
        lsof -i :5432 || echo "  Puerto 5432 Libre"
        lsof -i :6379 || echo "  Puerto 6379 Libre"

  health:
    desc: "ğŸ¥ Verificar salud de servicios"
    cmds:
      - task: health:local

  health:local:
    desc: "ğŸ¥ Verificar salud de servicios locales"
    cmds:
      - echo "ğŸ¥ Verificando salud de servicios..."
      - |
        if curl -s -I http://localhost:3000 | head -1 | grep -q "200\|30[0-9]"; then
          echo "âœ… Frontend (localhost:3000): OK"
        else
          echo "âŒ Frontend (localhost:3000): No responde"
        fi
      - |
        if curl -s http://localhost:8000/health > /dev/null 2>&1; then
          echo "âœ… Backend (localhost:8000): OK"
        else
          echo "âŒ Backend (localhost:8000): No responde"
        fi

  ports:
    desc: "ğŸ”Œ Verificar puertos en uso"
    cmds:
      - echo "ğŸ”Œ Verificando puertos..."
      - |
        for port in 3000 8000 5432 6379 80 443; do
          if lsof -i :$port > /dev/null 2>&1; then
            echo "âœ… Puerto $port en uso"
          else
            echo "âšª Puerto $port libre"
          fi
        done

  resources:
    desc: "ğŸ“ˆ Mostrar uso de recursos"
    cmds:
      - echo "ğŸ“ˆ Uso de recursos del sistema..."
      - echo "ğŸ³ EstadÃ­sticas de contenedores:"
      - docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
      - echo ""
      - echo "ğŸ’» Sistema:"
      - |
        top -l 1 | grep "CPU usage" || echo "  CPU: No disponible"
      - echo "ğŸ’¾ Disco:"
      - |
        df -h . | tail -1

  # ===== LIMPIEZA Y MANTENIMIENTO =====
  cleanup:
    desc: "ğŸ§¹ Limpiar puertos y cachÃ©s"
    cmds:
      - echo "ğŸ§¹ Limpiando puertos y cachÃ©s..."
      - task: cleanup:ports
      - task: cleanup:frontend
      - echo "âœ… Limpieza completada"

  cleanup:ports:
    desc: "ğŸ§¹ Limpiar solo puertos (3000, 3001, 8000, 8080)"
    cmds:
      - echo "ğŸ§¹ Limpiando puertos..."
      - ./scripts/cleanup-ports.sh
      - echo "âœ… Puertos limpiados"

  cleanup:frontend:
    desc: "ğŸ§¹ Limpiar cachÃ© y build del frontend"
    cmds:
      - echo "ğŸ§¹ Limpiando frontend..."
      - |
        cd cactus-wealth-frontend
        rm -rf .next node_modules/.cache dist build
        echo "ğŸ—‘ï¸ Archivos de build y cachÃ© eliminados"
      - echo "âœ… Frontend limpiado"

  # ===== AWS GESTIÃ“N =====
  aws:start:
    desc: "â–¶ï¸ Iniciar instancia EC2"
    cmds:
      - echo "â–¶ï¸ Iniciando instancia EC2..."
      - |
        current_state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        if [ "$current_state" = "running" ]; then
          echo "âš ï¸ La instancia ya estÃ¡ ejecutÃ¡ndose"
          ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "ğŸŒ IP pÃºblica: $ip"
          echo "ğŸ”— URL: http://$ip"
        else
          aws ec2 start-instances --instance-ids {{.AWS_INSTANCE_ID}} > /dev/null
          echo "â³ Esperando que la instancia estÃ© lista..."
          aws ec2 wait instance-running --instance-ids {{.AWS_INSTANCE_ID}}
          ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "âœ… Instancia iniciada exitosamente"
          echo "ğŸŒ IP pÃºblica: $ip"
          echo "ğŸ”— URL: http://$ip"
        fi

  aws:stop:
    desc: "â¹ï¸ Detener instancia EC2 (ahorrar dinero)"
    cmds:
      - echo "â¹ï¸ Deteniendo instancia EC2..."
      - |
        current_state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        if [ "$current_state" = "stopped" ]; then
          echo "âš ï¸ La instancia ya estÃ¡ detenida"
        else
          aws ec2 stop-instances --instance-ids {{.AWS_INSTANCE_ID}} > /dev/null
          echo "â³ Esperando que la instancia se detenga..."
          aws ec2 wait instance-stopped --instance-ids {{.AWS_INSTANCE_ID}}
          echo "âœ… Instancia detenida exitosamente"
          echo "ğŸ’° Â¡Dinero ahorrado! La instancia ya no genera costos"
        fi

  aws:status:
    desc: "ğŸ“Š Estado de la instancia EC2"
    cmds:
      - echo "ğŸ“Š Verificando estado de la instancia EC2..."
      - |
        state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        type=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].InstanceType' --output text 2>/dev/null || echo "unknown")
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        
        echo "ğŸ†” ID: {{.AWS_INSTANCE_ID}}"
        echo "ğŸ“¦ Tipo: $type"
        echo "ğŸ”„ Estado: $state"
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "ğŸŒ IP pÃºblica: $ip"
          echo "ğŸ”— URL: http://$ip"
        else
          echo "ğŸŒ IP pÃºblica: No asignada"
        fi

  aws:ip:
    desc: "ğŸŒ Obtener IP pÃºblica de la instancia"
    cmds:
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "ğŸŒ IP pÃºblica: $ip"
          echo "ğŸ”— URL: http://$ip"
        else
          echo "âŒ No hay IP pÃºblica asignada (instancia detenida?)"
        fi

  aws:costs:
    desc: "ğŸ’° Ver informaciÃ³n de costos"
    cmds:
      - echo "ğŸ’° InformaciÃ³n de costos AWS..."
      - |
        type=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].InstanceType' --output text 2>/dev/null || echo "unknown")
        state=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")
        
        echo "ğŸ“¦ Tipo de instancia: $type"
        echo "ğŸ”„ Estado actual: $state"
        echo ""
        echo "ğŸ’¡ Costos estimados por hora (regiÃ³n us-east-1):"
        case $type in
          "t2.micro") echo "   ğŸ’µ \$0.0116/hora (~\$8.50/mes)" ;;
          "t2.small") echo "   ğŸ’µ \$0.023/hora (~\$17/mes)" ;;
          "t2.medium") echo "   ğŸ’µ \$0.046/hora (~\$34/mes)" ;;
          "t3.micro") echo "   ğŸ’µ \$0.0104/hora (~\$7.60/mes)" ;;
          "t3.small") echo "   ğŸ’µ \$0.0208/hora (~\$15/mes)" ;;
          *) echo "   ğŸ’µ Consulta AWS Pricing para $type" ;;
        esac
        echo ""
        if [ "$state" = "running" ]; then
          echo "âš ï¸ La instancia estÃ¡ EJECUTÃNDOSE - generando costos"
          echo "ğŸ’¡ Usa 'task aws:stop' para detenerla y ahorrar dinero"
        else
          echo "âœ… La instancia estÃ¡ DETENIDA - sin costos de cÃ³mputo"
          echo "ğŸ’¡ Usa 'task aws:start' para iniciarla cuando la necesites"
        fi

  aws:ssh:
    desc: "ğŸ” Conectar SSH a la instancia"
    cmds:
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "ğŸ” Conectando SSH a $ip..."
          ssh -i {{.SSH_KEY}} ubuntu@$ip
        else
          echo "âŒ No se puede conectar: instancia sin IP pÃºblica"
          echo "ğŸ’¡ Usa 'task aws:start' primero"
        fi

  aws:health:
    desc: "ğŸ¥ Verificar salud de servicios en AWS"
    cmds:
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text 2>/dev/null || echo "none")
        if [ "$ip" != "none" ] && [ "$ip" != "null" ]; then
          echo "ğŸ¥ Verificando salud de servicios en $ip..."
          if curl -s -I http://$ip | head -1 | grep -q "200\|30[0-9]"; then
            echo "âœ… AplicaciÃ³n web: OK"
          else
            echo "âŒ AplicaciÃ³n web: No responde"
          fi
          if curl -s http://$ip/api/health > /dev/null 2>&1; then
            echo "âœ… API Backend: OK"
          else
            echo "âŒ API Backend: No responde"
          fi
        else
          echo "âŒ No se puede verificar: instancia sin IP pÃºblica"
        fi

  # ===== DESPLIEGUE =====
  deploy:aws:
    desc: "ğŸš€ Desplegar a AWS"
    cmds:
      - echo "ğŸš€ Desplegando CactusDashboard a AWS..."
      - task: aws:start
      - |
        ip=$(aws ec2 describe-instances --instance-ids {{.AWS_INSTANCE_ID}} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
        echo "ğŸ“¦ Desplegando aplicaciÃ³n en $ip..."
        
        if ssh -i {{.SSH_KEY}} -o ConnectTimeout=10 ubuntu@$ip "echo 'ConexiÃ³n SSH exitosa'" > /dev/null 2>&1; then
          echo "âœ… ConexiÃ³n SSH establecida"
          
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && docker-compose -f docker-compose.prod.yml down"
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && git pull origin main"
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && docker-compose -f docker-compose.prod.yml build"
          ssh -i {{.SSH_KEY}} ubuntu@$ip "cd /home/ubuntu/CactusDashboard && docker-compose -f docker-compose.prod.yml up -d"
          
          echo "â³ Esperando que los servicios estÃ©n listos..."
          sleep 30
          
          if curl -s -I http://$ip | head -1 | grep -q "200\|30[0-9]"; then
            echo "âœ… Despliegue exitoso!"
            echo "ğŸŒ AplicaciÃ³n disponible en: http://$ip"
          else
            echo "âŒ Error en el despliegue - la aplicaciÃ³n no responde"
          fi
        else
          echo "âŒ Error: No se puede conectar SSH a la instancia"
        fi

  # ===== CONFIGURACIÃ“N Y VALIDACIÃ“N =====
  docker:check:
    desc: "ğŸ³ Verificar y asegurar que Docker estÃ© ejecutÃ¡ndose"
    cmds:
      - echo "ğŸ³ Verificando Docker..."
      - ./scripts/check-docker.sh

  docker:setup:
    desc: "ğŸ³ Configurar Docker Desktop para inicio automÃ¡tico"
    cmds:
      - echo "ğŸ³ Configurando Docker Desktop..."
      - ./scripts/setup-docker-autostart.sh

  docker:diagnose:
    desc: "ğŸ” DiagnÃ³stico completo de Docker"
    cmds:
      - echo "ğŸ” Ejecutando diagnÃ³stico completo de Docker..."
      - ./scripts/diagnose-docker.sh

  setup:
    desc: "âš™ï¸ ConfiguraciÃ³n inicial del proyecto"
    cmds:
      - echo "âš™ï¸ Configurando CactusDashboard..."
      - echo "ğŸ“‹ Verificando dependencias..."
      - |
        docker --version || echo "âŒ Docker no instalado"
        docker-compose --version || echo "âŒ Docker Compose no instalado"
        aws --version || echo "âŒ AWS CLI no instalado"
      - echo "ğŸ“ Verificando archivos de configuraciÃ³n..."
      - |
        test -f docker-compose.prod.yml && echo "âœ… docker-compose.prod.yml" || echo "âŒ docker-compose.prod.yml no encontrado"
        test -f {{.SSH_KEY}} && echo "âœ… SSH key encontrada" || echo "âŒ SSH key {{.SSH_KEY}} no encontrada"
      - echo "âœ… ConfiguraciÃ³n inicial completada"

  validate:
    desc: "âœ… Validar configuraciÃ³n del proyecto"
    cmds:
      - echo "âœ… Validando configuraciÃ³n de CactusDashboard..."
      - task: setup
      - echo "ğŸ” Validando configuraciÃ³n AWS..."
      - |
        aws sts get-caller-identity > /dev/null && echo "âœ… AWS CLI configurado" || echo "âŒ AWS CLI no configurado"
      - echo "ğŸ” Validando instancia EC2..."
      - task: aws:status
      - echo "âœ… ValidaciÃ³n completada"

  # ===== OAUTH Y AUTENTICACIÃ“N =====
  oauth:verify:
    desc: "ğŸ” Verificar configuraciÃ³n OAuth"
    cmds:
      - echo "ğŸ” Verificando configuraciÃ³n OAuth..."
      - |
        if [ -f "cactus-wealth-frontend/.env.local" ]; then
          echo "ğŸ“ Archivo .env.local encontrado"
          
          nextauth_url=$(grep "NEXTAUTH_URL=" cactus-wealth-frontend/.env.local | cut -d'=' -f2 | tr -d '"' || echo "")
          google_client_id=$(grep "GOOGLE_CLIENT_ID=" cactus-wealth-frontend/.env.local | cut -d'=' -f2 | tr -d '"' || echo "")
          
          if [ ! -z "$nextauth_url" ]; then
            echo "âœ… NEXTAUTH_URL: $nextauth_url"
            echo ""
            echo "ğŸ”§ ConfiguraciÃ³n requerida en Google Console:"
            echo "   ğŸ“ Authorized JavaScript origins:"
            echo "      $nextauth_url"
            echo "   ğŸ“ Authorized redirect URIs:"
            echo "      $nextauth_url/api/auth/callback/google"
            echo ""
          else
            echo "âŒ NEXTAUTH_URL no encontrado en .env.local"
          fi
          
          if [ ! -z "$google_client_id" ]; then
            echo "âœ… GOOGLE_CLIENT_ID configurado"
          else
            echo "âŒ GOOGLE_CLIENT_ID no encontrado en .env.local"
          fi
          
          echo "ğŸ”— Google Console: https://console.developers.google.com/apis/credentials"
        else
          echo "âŒ Archivo .env.local no encontrado en cactus-wealth-frontend/"
          echo "ğŸ’¡ Crea el archivo basÃ¡ndote en .env.example"
        fi

  oauth:update:
    desc: "ğŸ”„ Actualizar credenciales OAuth de Google"
    cmds:
      - |
        echo "ğŸ”„ Actualizando credenciales OAuth..."
        echo ""
        echo "ğŸ“‹ Uso: task oauth:update CLIENT_ID=tu_client_id CLIENT_SECRET=tu_client_secret"
        echo ""
        echo "ğŸ“ Ejemplo:"
        echo "   task oauth:update CLIENT_ID=123456789-abcdef.apps.googleusercontent.com CLIENT_SECRET=GOCSPX-abcdef123456"
        echo ""
        echo "ğŸ”— Para obtener credenciales:"
        echo "   1. Ve a: https://console.cloud.google.com/apis/credentials"
        echo "   2. Crea OAuth 2.0 Client ID (Web application)"
        echo "   3. Configura URLs autorizadas:"
        echo "      - JavaScript origins: http://localhost:3000"
        echo "      - Redirect URIs: http://localhost:3000/api/auth/callback/google"
        echo ""
        
        if [ -z "{{.CLIENT_ID}}" ] || [ -z "{{.CLIENT_SECRET}}" ]; then
          echo "âŒ Error: Debes proporcionar CLIENT_ID y CLIENT_SECRET"
          echo ""
          echo "ğŸ’¡ Ejemplo de uso correcto:"
          echo "   task oauth:update CLIENT_ID=tu_client_id CLIENT_SECRET=tu_client_secret"
          exit 1
        fi
        
        echo "ğŸ”§ Ejecutando script de actualizaciÃ³n..."
        ./update-oauth-credentials.sh "{{.CLIENT_ID}}" "{{.CLIENT_SECRET}}"
        echo ""
        echo "âœ… Â¡Credenciales OAuth actualizadas!"
        echo "ğŸŒ Prueba la autenticaciÃ³n en: http://localhost:3000"

  oauth:diagnose:
    desc: "ğŸ” DiagnÃ³stico completo de OAuth"
    cmds:
      - echo "ğŸ” Ejecutando diagnÃ³stico completo de OAuth..."
      - ./diagnose-oauth.sh

  oauth:test:
    desc: "ğŸ§ª Probar configuraciÃ³n OAuth"
    cmds:
      - echo "ğŸ§ª Probando configuraciÃ³n OAuth..."
      - ./scripts/test-oauth.sh

  oauth:monitor:
    desc: "ğŸ“Š Monitorear estado OAuth automÃ¡ticamente"
    cmds:
      - echo "ğŸ“Š Iniciando monitoreo OAuth..."
      - ./scripts/monitor-oauth.sh

  oauth:setup-monitoring:
    desc: "ğŸ“Š Configurar monitoreo automÃ¡tico de OAuth"
    cmds:
      - echo "ğŸ“Š Configurando monitoreo automÃ¡tico de OAuth..."
      - ./scripts/setup-oauth-monitoring.sh

  # ===== AYUDA =====
  help:
    desc: "â“ Mostrar ayuda completa y organizada"
    cmds:
      - echo "ğŸŒµ CACTUS DASHBOARD - SISTEMA TASK UNIFICADO"
      - echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      - echo ""
      - echo "ğŸš€ DESARROLLO LOCAL:"
      - echo "  task dev              # Iniciar desarrollo completo"
      - echo "  task dev:stop         # Detener desarrollo"
      - echo "  task dev:restart      # Reiniciar desarrollo"
      - echo "  task dev:rebuild      # Rebuild completo"
      - echo ""
      - echo "ğŸ“º LOGS & DEBUGGING:"
      - echo "  task logs             # Ver logs en vivo (todos los servicios)"
      - echo "  task logs:backend     # Solo logs del backend"
      - echo "  task logs:frontend    # Solo logs del frontend"
      - echo "  task logs:db          # Solo logs de la base de datos"
      - echo "  task debug            # DiagnÃ³stico completo del sistema"
      - echo ""
      - echo "ğŸ“Š MONITOREO & ESTADO:"
      - echo "  task status           # Estado general del sistema"
      - echo "  task health           # Verificar salud de todos los servicios"
      - echo "  task ports            # Verificar puertos en uso"
      - echo "  task resources        # Mostrar uso de CPU, memoria y disco"
      - echo ""
      - echo "â˜ï¸ AWS MANAGEMENT:"
      - echo "  task aws:start        # Iniciar instancia EC2"
      - echo "  task aws:stop         # Detener instancia (ahorrar dinero)"
      - echo "  task aws:status       # Estado de la instancia EC2"
      - echo "  task aws:ip           # Obtener IP pÃºblica actual"
      - echo "  task aws:costs        # Ver informaciÃ³n de costos"
      - echo "  task aws:ssh          # Conectar SSH a la instancia"
      - echo "  task aws:health       # Verificar salud de servicios en AWS"
      - echo ""
      - echo "ğŸš€ DEPLOYMENT:"
      - echo "  task deploy:aws       # Desplegar aplicaciÃ³n completa a AWS"
      - echo ""
      - echo "ğŸ” OAUTH & AUTENTICACIÃ“N:"
      - echo "  task oauth:verify     # Verificar configuraciÃ³n OAuth"
      - echo "  task oauth:update     # Actualizar credenciales OAuth"
      - echo "  task oauth:diagnose   # DiagnÃ³stico completo de OAuth"
      - echo "  task oauth:test       # Probar configuraciÃ³n OAuth"
      - echo "  task oauth:monitor    # Monitorear estado OAuth automÃ¡ticamente"
      - echo "  task oauth:setup-permanent # Configurar OAuth permanente"
      - echo ""
      - echo "âš™ï¸ CONFIGURACIÃ“N & UTILIDADES:"
      - echo "  task setup            # ConfiguraciÃ³n inicial del proyecto"
      - echo "  task validate         # Validar toda la configuraciÃ³n"
      - echo "  task docker:check     # Verificar Docker"
      - echo "  task docker:setup     # Configurar Docker Desktop"
      - echo "  task docker:diagnose  # DiagnÃ³stico completo de Docker"
      - echo "  task cleanup          # Limpiar puertos y cachÃ©s"
      - echo ""
      - echo "â“ AYUDA & INFORMACIÃ“N:"
      - echo "  task help             # Esta ayuda completa"
      - echo "  task help:quick       # Ayuda rÃ¡pida (comandos esenciales)"
      - echo "  task --list           # Lista rÃ¡pida de todos los comandos"
      - echo ""
      - echo "ğŸ’¡ EJEMPLOS DE USO:"
      - echo "  ğŸ¯ Desarrollo diario: task dev, task logs, task status, task dev:stop"
      - echo "  â˜ï¸ GestiÃ³n AWS: task aws:start, task deploy:aws, task aws:stop"
      - echo "  ğŸ” OAuth: task oauth:diagnose, task oauth:update, task oauth:test"
      - echo "  ğŸ”§ Troubleshooting: task debug, task cleanup, task validate"
      - echo ""
      - echo "ğŸ‰ SISTEMA UNIFICADO:"
      - echo "  âœ… Todos los scripts consolidados en Task"
      - echo "  âœ… Sintaxis consistente: task <comando>"
      - echo "  âœ… DocumentaciÃ³n integrada y autocompletado"
      - echo "  âœ… OptimizaciÃ³n del 90%+ en tiempos de ejecuciÃ³n"
      - echo ""
      - echo "ğŸ“š DocumentaciÃ³n: DOCUMENTATION.md, TASK_SYSTEM.md, QUICK_REFERENCE.md"

  help:quick:
    desc: "âš¡ Ayuda rÃ¡pida - comandos esenciales"
    cmds:
      - |
        echo ""
        echo "âš¡ COMANDOS ESENCIALES - CACTUS DASHBOARD"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "ğŸš€ DESARROLLO:"
        echo "   task dev              # Iniciar desarrollo"
        echo "   task dev:stop         # Detener desarrollo"
        echo "   task logs             # Ver logs en vivo"
        echo "   task status           # Estado del sistema"
        echo ""
        echo "â˜ï¸ AWS:"
        echo "   task aws:start        # Iniciar instancia EC2"
        echo "   task aws:stop         # Detener instancia (ahorrar dinero)"
        echo "   task deploy:aws       # Desplegar a AWS"
        echo ""
        echo "ğŸ” OAUTH:"
        echo "   task oauth:diagnose   # DiagnÃ³stico OAuth"
        echo "   task oauth:test       # Probar OAuth"
        echo "   task oauth:update     # Actualizar credenciales"
        echo ""
        echo "ğŸ”§ UTILIDADES:"
        echo "   task debug            # DiagnÃ³stico completo"
        echo "   task cleanup          # Limpiar puertos"
        echo "   task help             # Ayuda completa"
        echo ""
        echo "ğŸ’¡ Usa 'task help' para ver todos los comandos disponibles"
        echo ""